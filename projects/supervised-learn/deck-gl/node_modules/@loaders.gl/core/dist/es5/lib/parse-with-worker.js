"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = parseWithWorker;

var _binaryUtils = require("../javascript-utils/binary-utils");

var workerCache = new Map();
var counters = {};

function getDecoratedWorkerName(workerName) {
  var lowerCaseName = workerName ? workerName.toLowerCase() : 'unnamed';
  counters[lowerCaseName] = counters[lowerCaseName] || 0;
  var counter = counters[lowerCaseName]++;
  return "loaders.gl-".concat(lowerCaseName, "-worker-").concat(counter);
}

function getWorker(workerSource, workerName) {
  var workerURL = workerCache.get(workerSource);

  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: 'application/javascript'
    });
    workerURL = URL.createObjectURL(blob);
    workerCache.set(workerSource, workerURL);
  }

  return new Worker(workerURL, {
    name: getDecoratedWorkerName(workerName)
  });
}

function parseWithWorker(workerSource, workerName, data, options) {
  var worker = getWorker(workerSource, workerName);
  options = removeNontransferableOptions(options);

  var parse = function parse(rawData, opts) {
    return new Promise(function (resolve, reject) {
      worker.onmessage = function (evt) {
        switch (evt.data.type) {
          case 'done':
            resolve(evt.data.result);
            worker.terminate();
            break;

          case 'error':
            reject(new Error(evt.data.message));
            break;

          default:
        }
      };

      var arraybuffer = (0, _binaryUtils.toArrayBuffer)(rawData);
      worker.postMessage({
        arraybuffer: arraybuffer,
        opts: opts
      }, [arraybuffer]);
    });
  };

  return data ? parse(data, options) : parse;
}

function removeNontransferableOptions(options) {
  options = Object.assign({}, options);

  if (options.log !== null) {
    delete options.log;
  }

  return options;
}
//# sourceMappingURL=parse-with-worker.js.map