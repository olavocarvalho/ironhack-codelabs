{"version":3,"sources":["../../../src/lib/parse-with-loader.js"],"names":["assert","parseWithWorker","getArrayBufferOrStringFromDataSync","getArrayBufferOrStringFromData","getAsyncIteratorFromData","getIteratorFromData","parseWithLoader","data","loader","options","url","parseTextSync","dataType","parse","parseSync","worker","name","parseWithLoaderSync","parseWithLoaderInBatches","parseInBatches","inputIterator","outputIterator","parseWithLoaderInBatchesSync","parseInBatchesSync"],"mappings":";AAAA,OAAOA,MAAP,MAAmB,iBAAnB;AACA,OAAOC,eAAP,MAA4B,qBAA5B;AACA,SACEC,kCADF,EAEEC,8BAFF,EAGEC,wBAHF,EAIEC,mBAJF,QAKO,yBALP;AAUA,gBAAsBC,eAAtB;AAAA;AAAA;;;uCAAO,WAA+BC,IAA/B,EAAqCC,MAArC,EAA6CC,OAA7C,EAAsDC,GAAtD,EAA2D;AAChEH,IAAAA,IAAI,SAASJ,8BAA8B,CAACI,IAAD,EAAOC,MAAP,CAA3C;;AAGA,QAAIA,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QAA5C,EAAsD;AACpDE,MAAAA,OAAO,CAACG,QAAR,GAAmB,MAAnB;AACA,aAAOJ,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CAAP;AACD;;AAGD,QAAIA,MAAM,CAACK,KAAX,EAAkB;AAChB,mBAAaL,MAAM,CAACK,KAAP,CAAaN,IAAb,EAAmBE,OAAnB,EAA4BC,GAA5B,EAAiCF,MAAjC,CAAb;AACD;;AAGD,QAAIA,MAAM,CAACM,SAAX,EAAsB;AACpB,aAAON,MAAM,CAACM,SAAP,CAAiBP,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAAP;AACD;;AAED,QAAIA,MAAM,CAACO,MAAX,EAAmB;AACjB,aAAOd,eAAe,CAACO,MAAM,CAACO,MAAR,EAAgBP,MAAM,CAACQ,IAAvB,EAA6BT,IAA7B,EAAmCE,OAAnC,CAAtB;AACD;;AAID,WAAOT,MAAM,CAAC,KAAD,CAAb;AACD,G;;;;AAGD,OAAO,SAASiB,mBAAT,CAA6BV,IAA7B,EAAmCC,MAAnC,EAA2CC,OAA3C,EAAoDC,GAApD,EAAyD;AAC9DH,EAAAA,IAAI,GAAGL,kCAAkC,CAACK,IAAD,EAAOC,MAAP,CAAzC;;AAEA,MAAIA,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QAA5C,EAAsD;AACpD,WAAOC,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CAAP;AACD;;AAED,MAAIA,MAAM,CAACM,SAAX,EAAsB;AACpB,WAAON,MAAM,CAACM,SAAP,CAAiBP,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAAP;AACD;;AAID,SAAOR,MAAM,CAAC,KAAD,CAAb;AACD;AAED,OAAO,SAASkB,wBAAT,CAAkCX,IAAlC,EAAwCC,MAAxC,EAAgDC,OAAhD,EAAyDC,GAAzD,EAA8D;AAEnE,MAAIF,MAAM,CAACW,cAAX,EAA2B;AACzB,QAAMC,aAAa,GAAGhB,wBAAwB,CAACG,IAAD,CAA9C;AACA,QAAMc,cAAc,GAAGb,MAAM,CAACW,cAAP,CAAsBC,aAAtB,EAAqCX,OAArC,EAA8CC,GAA9C,EAAmDF,MAAnD,CAAvB;AACA,WAAOa,cAAP;AACD;;AAGD,SAAO,IAAP;AACD;AAED,OAAO,SAASC,4BAAT,CAAsCf,IAAtC,EAA4CC,MAA5C,EAAoDC,OAApD,EAA6DC,GAA7D,EAAkE;AAEvE,MAAIF,MAAM,CAACe,kBAAX,EAA+B;AAC7B,QAAMH,aAAa,GAAGf,mBAAmB,CAACE,IAAD,CAAzC;AACA,QAAMc,cAAc,GAAGb,MAAM,CAACe,kBAAP,CAA0BH,aAA1B,EAAyCX,OAAzC,EAAkDC,GAAlD,EAAuDF,MAAvD,EAA+DE,GAA/D,CAAvB;AACA,WAAOW,cAAP;AACD;;AAED,SAAOrB,MAAM,CAAC,KAAD,CAAb;AACD","sourcesContent":["import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options, url) {\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return parseWithWorker(loader.worker, loader.name, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport function parseWithLoaderInBatches(data, loader, options, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport function parseWithLoaderInBatchesSync(data, loader, options, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n"],"file":"parse-with-loader.js"}