import { toArrayBuffer } from '../javascript-utils/binary-utils';
var workerCache = new Map();
var counters = {};

function getDecoratedWorkerName(workerName) {
  var lowerCaseName = workerName ? workerName.toLowerCase() : 'unnamed';
  counters[lowerCaseName] = counters[lowerCaseName] || 0;
  var counter = counters[lowerCaseName]++;
  return "loaders.gl-".concat(lowerCaseName, "-worker-").concat(counter);
}

function getWorker(workerSource, workerName) {
  var workerURL = workerCache.get(workerSource);

  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: 'application/javascript'
    });
    workerURL = URL.createObjectURL(blob);
    workerCache.set(workerSource, workerURL);
  }

  return new Worker(workerURL, {
    name: getDecoratedWorkerName(workerName)
  });
}

export default function parseWithWorker(workerSource, workerName, data, options) {
  var worker = getWorker(workerSource, workerName);
  options = removeNontransferableOptions(options);

  var parse = (rawData, opts) => new Promise((resolve, reject) => {
    worker.onmessage = evt => {
      switch (evt.data.type) {
        case 'done':
          resolve(evt.data.result);
          worker.terminate();
          break;

        case 'error':
          reject(new Error(evt.data.message));
          break;

        default:
      }
    };

    var arraybuffer = toArrayBuffer(rawData);
    worker.postMessage({
      arraybuffer,
      opts
    }, [arraybuffer]);
  });

  return data ? parse(data, options) : parse;
}

function removeNontransferableOptions(options) {
  options = Object.assign({}, options);

  if (options.log !== null) {
    delete options.log;
  }

  return options;
}
//# sourceMappingURL=parse-with-worker.js.map