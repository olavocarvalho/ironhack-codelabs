{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["KHR_draco_mesh_compression","gltfData","options","gltfScenegraph","GLTFScenegraph","json","meshes","mesh","decompressMesh","removeExtension","KHR_DRACO_MESH_COMPRESSION","compressMesh","addRequiredExtension","attributes","indices","mode","DracoWriter","DracoLoader","Error","compressedData","encodeSync","decodedData","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","bufferView","primitive","_decompressMeshPrimitive","Object","keys","length","compressedPrimitive","decompress","buffer","_getBufferViewArray"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nexport default class KHR_draco_mesh_compression {\n  static get name() {\n    return KHR_DRACO_MESH_COMPRESSION;\n  }\n\n  static decode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.decompressMesh(mesh, options);\n    }\n\n    // We have now decompressed all primitives, we can remove the top-level extensions\n    gltfScenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n\n  static encode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.compressMesh(mesh, options);\n      // NOTE: We only add if something was actually compressed\n      gltfScenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  }\n\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  // Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n  static compressMesh(attributes, indices, mode = 4, options = {}) {\n    if (!options.DracoWriter || !options.DracoLoader) {\n      throw new Error('DracoWriter/DracoLoader not available');\n    }\n\n    const compressedData = options.DracoWriter.encodeSync({attributes});\n\n    // Draco compression may change the order and number of vertices in a mesh.\n    // To satisfy the requirement that accessors properties be correct for both\n    // compressed and uncompressed data, generators should create uncompressed\n    // attributes and indices using data that has been decompressed from the Draco buffer,\n    // rather than the original source data.\n    const decodedData = options.DracoLoader.parseSync({attributes});\n    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n    const bufferViewIndex = options.addBufferView(compressedData);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: fauxAccessors, // TODO - verify with spec\n          mode, // GL.POINTS\n          extensions: {\n            [KHR_DRACO_MESH_COMPRESSION]: {\n              bufferView: bufferViewIndex,\n              attributes: fauxAccessors // TODO - verify with spec\n            }\n          }\n        }\n      ]\n    };\n\n    return glTFMesh;\n  }\n\n  static decompressMesh(mesh, options = {}) {\n    // We have a \"soft dependency\" on Draco to avoid bundling it when not needed\n    // DracoEncoder needs to be imported and supplied by app\n    // Decompress all the primitives in a mesh\n    for (const primitive of mesh.primitives) {\n      KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);\n      if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {\n        throw new Error('Empty glTF primitive: decompression failure?');\n      }\n    }\n  }\n\n  // Unpacks one mesh primitive and removes the extension from the primitive\n  // TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n  // TODO - Decompression could be threaded: Use DracoWorkerLoader?\n  //\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  static _decompressMeshPrimitive(primitive, options) {\n    const compressedPrimitive =\n      primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n    if (!compressedPrimitive) {\n      return;\n    }\n\n    if (!options.DracoLoader || !options.decompress) {\n      return;\n    }\n\n    // Extension will be processed, delete it\n    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n    const buffer = this._getBufferViewArray(compressedPrimitive.bufferView);\n    const decodedData = options.DracoLoader.parseSync(buffer);\n    primitive.attributes = getGLTFAccessors(decodedData.attributes);\n    if (decodedData.indices) {\n      primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n  }\n}\n"],"file":"KHR_draco_mesh_compression.js"}