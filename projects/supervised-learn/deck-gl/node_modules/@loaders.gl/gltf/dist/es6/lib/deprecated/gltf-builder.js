import { getImageMetadata } from '@loaders.gl/images';
import assert from '../utils/assert';
import { KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION } from '../gltf-constants';
import GLBBuilder from './glb-builder';
import packBinaryJson from './packed-json/pack-binary-json';
export default class GLTFBuilder extends GLBBuilder {
  constructor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(options);
    this.DracoWriter = options.DracoWriter;
    this.DracoLoader = options.DracoLoader;
  }

  addApplicationData(key, data) {
    var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var jsonData = packOptions.packTypedArrays ? packBinaryJson(data, this, packOptions) : data;
    this.json[key] = jsonData;
    return this;
  }

  addExtraData(key, data) {
    var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var packedJson = packOptions.packedTypedArrays ? packBinaryJson(data, this, packOptions) : data;
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = packedJson;
    return this;
  }

  addExtension(extensionName, data) {
    var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    assert(data);
    var packedJson = packOptions.packTypedArrays ? packBinaryJson(data, this, packOptions) : data;
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = packedJson;
    this.registerUsedExtension(extensionName);
    return this;
  }

  addRequiredExtension(extensionName, data) {
    var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    assert(data);
    var packedJson = packOptions.packTypedArrays ? packBinaryJson(data, this, packOptions) : data;
    this.addExtension(extensionName, packedJson);
    this.registerRequiredExtension(extensionName);
    return this;
  }

  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];

    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }

  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];

    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }

  addMesh(attributes, indices) {
    var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

    var accessors = this._addAttributes(attributes);

    var glTFMesh = {
      primitives: [{
        attributes: accessors,
        indices,
        mode
      }]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addPointCloud(attributes) {
    var accessorIndices = this._addAttributes(attributes);

    var glTFMesh = {
      primitives: [{
        attributes: accessorIndices,
        mode: 0
      }]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addCompressedMesh(attributes, indices) {
    var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

    if (!this.DracoWriter || !this.DracoLoader) {
      throw new Error('DracoWriter/DracoLoader not available');
    }

    this.registerRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    var compressedData = this.DracoWriter.encodeSync({
      attributes
    });
    var decodedData = this.DracoLoader.parseSync({
      attributes
    });

    var fauxAccessors = this._addFauxAttributes(decodedData.attributes);

    var bufferViewIndex = this.addBufferView(compressedData);
    var glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addCompressedPointCloud(attributes) {
    if (!this.DracoWriter || !this.DracoLoader) {
      throw new Error('DracoWriter/DracoLoader not available');
    }

    attributes.mode = 0;
    var compressedData = this.DracoWriter.encodeSync(attributes, {
      pointcloud: true
    });
    var bufferViewIndex = this.addBufferView(compressedData);
    var glTFMesh = {
      primitives: [{
        attributes: {},
        mode: 0,
        extensions: {
          [UBER_POINT_CLOUD_EXTENSION]: {
            bufferView: bufferViewIndex
          }
        }
      }]
    };
    this.registerRequiredExtension(UBER_POINT_CLOUD_EXTENSION);
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addImage(imageData) {
    var bufferViewIndex = this.addBufferView(imageData);
    var sizeAndType = getImageMetadata(imageData) || {};

    if (sizeAndType) {
      var {
        mimeType,
        width,
        height
      } = sizeAndType;
      this.json.images.push({
        bufferView: bufferViewIndex,
        mimeType,
        width,
        height
      });
    } else {
      this.json.images.push({
        bufferView: bufferViewIndex
      });
    }

    return this.json.images.length - 1;
  }

}
//# sourceMappingURL=gltf-builder.js.map