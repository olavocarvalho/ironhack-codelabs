{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["GLTFScenegraph","KHR_DRACO_MESH_COMPRESSION","getGLTFAccessors","getGLTFAccessor","KHR_draco_mesh_compression","name","decode","gltfData","options","gltfScenegraph","mesh","json","meshes","decompressMesh","removeExtension","encode","compressMesh","addRequiredExtension","attributes","indices","mode","DracoWriter","DracoLoader","Error","compressedData","encodeSync","decodedData","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","bufferView","primitive","_decompressMeshPrimitive","Object","keys","length","compressedPrimitive","decompress","buffer","_getBufferViewArray"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nexport default class KHR_draco_mesh_compression {\n  static get name() {\n    return KHR_DRACO_MESH_COMPRESSION;\n  }\n\n  static decode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.decompressMesh(mesh, options);\n    }\n\n    // We have now decompressed all primitives, we can remove the top-level extensions\n    gltfScenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n\n  static encode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.compressMesh(mesh, options);\n      // NOTE: We only add if something was actually compressed\n      gltfScenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  }\n\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  // Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n  static compressMesh(attributes, indices, mode = 4, options = {}) {\n    if (!options.DracoWriter || !options.DracoLoader) {\n      throw new Error('DracoWriter/DracoLoader not available');\n    }\n\n    const compressedData = options.DracoWriter.encodeSync({attributes});\n\n    // Draco compression may change the order and number of vertices in a mesh.\n    // To satisfy the requirement that accessors properties be correct for both\n    // compressed and uncompressed data, generators should create uncompressed\n    // attributes and indices using data that has been decompressed from the Draco buffer,\n    // rather than the original source data.\n    const decodedData = options.DracoLoader.parseSync({attributes});\n    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n    const bufferViewIndex = options.addBufferView(compressedData);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: fauxAccessors, // TODO - verify with spec\n          mode, // GL.POINTS\n          extensions: {\n            [KHR_DRACO_MESH_COMPRESSION]: {\n              bufferView: bufferViewIndex,\n              attributes: fauxAccessors // TODO - verify with spec\n            }\n          }\n        }\n      ]\n    };\n\n    return glTFMesh;\n  }\n\n  static decompressMesh(mesh, options = {}) {\n    // We have a \"soft dependency\" on Draco to avoid bundling it when not needed\n    // DracoEncoder needs to be imported and supplied by app\n    // Decompress all the primitives in a mesh\n    for (const primitive of mesh.primitives) {\n      KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);\n      if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {\n        throw new Error('Empty glTF primitive: decompression failure?');\n      }\n    }\n  }\n\n  // Unpacks one mesh primitive and removes the extension from the primitive\n  // TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n  // TODO - Decompression could be threaded: Use DracoWorkerLoader?\n  //\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  static _decompressMeshPrimitive(primitive, options) {\n    const compressedPrimitive =\n      primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n    if (!compressedPrimitive) {\n      return;\n    }\n\n    if (!options.DracoLoader || !options.decompress) {\n      return;\n    }\n\n    // Extension will be processed, delete it\n    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n    const buffer = this._getBufferViewArray(compressedPrimitive.bufferView);\n    const decodedData = options.DracoLoader.parseSync(buffer);\n    primitive.attributes = getGLTFAccessors(decodedData.attributes);\n    if (decodedData.indices) {\n      primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n  }\n}\n"],"file":"KHR_draco_mesh_compression.js"}