{"version":3,"sources":["../../../src/lib/parse-glb.js"],"names":["padTo4Bytes","assert","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","LE","BE","getMagicString","dataView","String","fromCharCode","getUint8","isGLB","arrayBuffer","byteOffset","options","DataView","magic","magic1","getUint32","parseGLBSync","glb","version","byteLength","type","isMagicValid","console","warn","jsonChunkLength","jsonChunkFormat","isJSONChunk","jsonChunkByteOffset","jsonChunk","Uint8Array","textDecoder","TextDecoder","jsonText","decode","json","JSON","parse","binChunkStart","hasBinChunk","binChunkLength","binChunkFormat","isBinChunk","binChunkByteOffset"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\n/* global TextDecoder */\nimport {padTo4Bytes, assert} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\n\nfunction getMagicString(dataView) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(0))}\\\n${String.fromCharCode(dataView.getUint8(1))}\\\n${String.fromCharCode(dataView.getUint8(2))}\\\n${String.fromCharCode(dataView.getUint8(3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n/*\nReturns {\n  // Header\n  type: String,\n  magic: number,\n  version: number,\n  byteLength: number,\n  byteOffset: number,\n\n  // JSON Chunk\n  json: any,\n\n  // BIN Chunk\n  hasBinChunk: boolean,\n  binChunkByteOffset: number,\n  binChunkLength: number\n}\n*/\nexport default function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  glb.byteOffset = byteOffset; // Byte offset into the initial arrayBuffer\n\n  // GLB Header\n  glb.magic = dataView.getUint32(byteOffset + 0, BE); // Magic number (the ASCII string 'glTF').\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  glb.byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  glb.type = getMagicString(dataView);\n\n  // TODO - switch type checks to use strings\n  const {magic = MAGIC_glTF} = options;\n  const isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;\n  if (!isMagicValid) {\n    console.warn(`Invalid GLB magic string ${glb.type}`); // eslint-disable-line\n  }\n\n  assert(glb.version === 2, `Invalid GLB version ${glb.version}. Only .glb v2 supported`);\n  assert(glb.byteLength > 20);\n\n  // TODO - per spec we must iterate over chunks, ignoring all except JSON and BIN\n\n  // Parse the JSON chunk\n\n  const jsonChunkLength = dataView.getUint32(byteOffset + 12, LE); // Byte length of json chunk\n  const jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE); // Chunk format as uint32\n\n  // Check JSON Chunk format (0 = Back compat)\n  const isJSONChunk = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0;\n  assert(isJSONChunk, `JSON chunk format ${jsonChunkFormat}`);\n\n  // Create a \"view\" of the binary encoded JSON data\n  const jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n  const jsonChunk = new Uint8Array(arrayBuffer, byteOffset + jsonChunkByteOffset, jsonChunkLength);\n\n  // Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  const binChunkStart = jsonChunkByteOffset + padTo4Bytes(jsonChunkLength);\n\n  // Parse and check BIN chunk header\n  // Note: BIN chunk can be optional\n  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;\n\n  if (glb.hasBinChunk) {\n    const binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);\n    const binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);\n\n    const isBinChunk = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1; // Back compat\n    assert(isBinChunk, `BIN chunk format ${binChunkFormat}`);\n\n    const binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;\n\n    // TODO - copy or create typed array view\n    glb.binChunkByteOffset = binChunkByteOffset;\n    glb.binChunkLength = binChunkLength;\n  }\n\n  return byteOffset + glb.byteLength;\n}\n"],"file":"parse-glb.js"}