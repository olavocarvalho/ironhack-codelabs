{"version":3,"sources":["../../../src/lib/transform.js"],"names":["SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","Transform","gl","props","model","elementCount","currentIndex","sourceBuffers","Array","sourceTextures","feedbackBuffers","targetTextures","transformFeedbacks","framebuffers","resources","elementIDBuffer","_targetRefTexName","_initialize","Object","seal","name","varyingName","bufferOrParams","Buffer","buffer","attachments","packed","getBuffer","getData","targetTextureVarying","pixels","ArrayType","constructor","channelCount","targetTextureType","packedPixels","length","packCount","i","j","uniforms","current","attributes","assign","hasSourceTextures","transform_elementID","sampler","samplerTextureMap","textureName","_setSourceTextureParameters","sizeUniforms","sourceTextureMap","targetTexture","opts","_getInputs","parameters","clearRenderTarget","framebuffer","discard","renderingToTexture","viewport","width","height","clear","color","setAttributes","transform","transformFeedback","log","deprecated","swap","feedbackMap","_swapTexture","_setElementCount","bufferName","_createFeedbackBuffers","setBuffers","_setupSwapBuffers","_sourceTextures","_targetTexture","_updateTargetTexture","_setupSwapTextures","index","setParameters","_updateElementIDBuffer","setVertexCount","texture","_buildTargetTexture","update","resizeAttachments","resize","_validateProps","varyings","_targetTextureVarying","varyingsArray","isArray","values","_setupBuffers","_setupTextures","_buildModel","id","drawMode","destinationBuffers","sourceDestinationMap","vs","Texture2D","keys","textureOrAttribute","refTexture","pixelStore","resourceName","sourceBufferName","feedbackBufferName","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","next","srcName","dstName","_getShaders","fs","modules","inject","Model","vertexCount","_setupTransformFeedback","_setupFramebuffers","TransformFeedback","program","buffers","Framebuffer","elementIds","Float32Array","forEach","_","array","data","size","setData","_processVertexShader","combinedInject","_fs","version","input","inputType","output","concat"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {combineInjects} from '@luma.gl/shadertools';\nimport {_transform as transform, getPassthroughFS, typeToChannelCount} from '@luma.gl/shadertools';\nimport {\n  isWebGL2,\n  Buffer,\n  Framebuffer,\n  Texture2D,\n  TransformFeedback,\n  readPixelsToArray,\n  getShaderVersion,\n  cloneTextureFrom\n} from '@luma.gl/webgl';\nimport {log, isObjectEmpty, assert} from '../utils';\nimport Model from './model';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class Transform {\n  static isSupported(gl) {\n    // For now WebGL2 only\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assert(isWebGL2(gl));\n\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.currentIndex = 0;\n\n    // Source and destination resources are stored in two element Arrays for easier swapping when\n    // 'feedbackMap' is provided. If not only the first array elment is used.\n\n    // Each array element is an object with attribute name as Key and Buffer object as value.\n    this.sourceBuffers = new Array(2);\n\n    // Each array element is an object with attribute name as Key and Texture object as value.\n    this.sourceTextures = new Array(2);\n\n    // Each array element is an object with varying name as Key and Buffer object as value.\n    this.feedbackBuffers = new Array(2);\n\n    // Each array element is a Texture object used as color attachment for framebuffer.\n    this.targetTextures = new Array(2);\n\n    // Each array element is a TransformFeedback object.\n    this.transformFeedbacks = new Array(2);\n\n    // Each array element is a Framebuffer object.\n    this.framebuffers = new Array(2);\n\n    this.resources = {}; // resources to be deleted\n\n    this.elementIDBuffer = null;\n\n    // reference source texture name for target texture\n    this._targetRefTexName = null;\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n    this.model.delete();\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    const bufferOrParams = varyingName\n      ? this.feedbackBuffers[this.currentIndex][varyingName]\n      : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  // Returns the color attachment textuer from current framebuffer target\n  _getTargetTexture() {\n    if (this.framebuffers[this.currentIndex]) {\n      return this.framebuffers[this.currentIndex].attachments[GL.COLOR_ATTACHMENT0];\n    }\n    return null;\n  }\n\n  // Return data either from Buffer or from Texture\n  getData({varyingName = null, packed = false} = {}) {\n    // Either there should be specified feedbackBuffer or we should be rendering to a texture\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n\n    // When varyingName is not provided return data from framebuffer object.\n    assert(!varyingName || varyingName === this.targetTextureVarying);\n\n    const pixels = readPixelsToArray(this.framebuffers[this.currentIndex]);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    return this.framebuffers[this.currentIndex];\n  }\n\n  _getInputs() {\n    const uniforms = {};\n    const current = this.currentIndex;\n\n    // Buffer inputs\n    const attributes = Object.assign({}, this.sourceBuffers[current]);\n\n    // Texture inputs\n    if (this.hasSourceTextures || this.targetTextureVarying) {\n      // TODO: add option not generate position using element id.\n      attributes.transform_elementID = this.elementIDBuffer;\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = this.sourceTextures[current][textureName];\n      }\n      // Also update size uniforms , add samplerSizeMap\n      this._setSourceTextureParameters();\n\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: this.sourceTextures[current],\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture: this.targetTextures[current]\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n    return {attributes, uniforms};\n  }\n\n  // Run one transform feedback loop.\n  run(opts = {}) {\n    const {attributes, uniforms} = this._getInputs();\n    Object.assign(uniforms, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    const {clearRenderTarget = true} = opts;\n    let framebuffer = null;\n    let discard = true;\n\n    if (this.renderingToTexture) {\n      discard = false;\n      framebuffer = this.framebuffers[this.currentIndex];\n      assert(framebuffer);\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n      if (clearRenderTarget) {\n        framebuffer.clear({color: true});\n      }\n    }\n    this.model.setAttributes(attributes);\n    this.model.transform(\n      Object.assign({}, opts, {\n        transformFeedback: this.transformFeedbacks[this.currentIndex],\n        uniforms,\n        discard,\n        framebuffer,\n        parameters\n      })\n    );\n  }\n\n  // Swap source and destination buffers and textures.\n  swapBuffers() {\n    log.deprecated('swapBuffers()', 'swap()')();\n    this.swap();\n  }\n\n  // Swap source and destination buffers and textures.\n  swap() {\n    assert(this.feedbackMap || this._swapTexture);\n    this.currentIndex = (this.currentIndex + 1) % 2;\n  }\n\n  // Update some or all buffer bindings.\n  update(opts = {}) {\n    if (opts.elementCount) {\n      this._setElementCount(opts.elementCount);\n    }\n\n    const {sourceBuffers = null, feedbackBuffers = null} = opts;\n    const {currentIndex} = this;\n    if (sourceBuffers || feedbackBuffers) {\n      for (const bufferName in feedbackBuffers) {\n        assert(\n          feedbackBuffers[bufferName] instanceof Buffer ||\n            feedbackBuffers[bufferName].buffer instanceof Buffer\n        );\n      }\n\n      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);\n      Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);\n      this._createFeedbackBuffers({feedbackBuffers});\n      if (this.transformFeedbacks[currentIndex]) {\n        this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);\n      }\n\n      // Buffers have changed, need to re-setup swap buffers.\n      this._setupSwapBuffers();\n    }\n\n    const {_sourceTextures, _targetTexture} = opts;\n    if (_sourceTextures || _targetTexture) {\n      Object.assign(this.sourceTextures[currentIndex], _sourceTextures);\n      // if _targetTexture specified use it, other wise rebuild traget texture using\n      // '_targetRefTexName' as coresponding source texture may have been update.\n      this._updateTargetTexture(_targetTexture || this._targetRefTexName, currentIndex);\n      // textures have changed, need to re-setup swap textures.\n      this._setupSwapTextures();\n    }\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    for (const name in this.sourceTextures[index]) {\n      this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  // set element count and updated elementID buffer if needed.\n  _setElementCount(elementCount) {\n    if (this.elementCount === elementCount) {\n      return;\n    }\n    if (this.elementCount < elementCount) {\n      this._updateElementIDBuffer(elementCount);\n    }\n    this.model.setVertexCount(elementCount);\n    this.elementCount = elementCount;\n  }\n\n  // sets target texture for rendering by updating framebuffer\n  _updateTargetTexture(texture, index) {\n    const targetTexture = this._buildTargetTexture(texture, index);\n    if (targetTexture) {\n      this.targetTextures[index] = targetTexture;\n      if (this.framebuffers[index]) {\n        // First update texture without re-sizing attachments\n        this.framebuffers[index].update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: this.targetTextures[index]},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        this.framebuffers[index].resize({\n          width: targetTexture.width,\n          height: targetTexture.height\n        });\n      }\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {feedbackBuffers, feedbackMap} = this._validateProps(props);\n    const {sourceBuffers, varyings, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    let varyingsArray = varyings;\n    if (feedbackMap && !Array.isArray(varyings)) {\n      varyingsArray = Object.values(feedbackMap);\n    }\n    this.varyingsArray = varyingsArray;\n    this.feedbackMap = feedbackMap;\n    this._swapTexture = _swapTexture;\n    if (_targetTexture) {\n      this.targetTextureVarying = _targetTextureVarying;\n      this.renderingToTexture = true;\n      assert(this.targetTextureVarying);\n    }\n\n    this._setupBuffers({sourceBuffers, feedbackBuffers});\n    this._setupTextures(props);\n    this._setupSwapBuffers();\n    this._setupSwapTextures();\n    this._buildModel(\n      Object.assign({}, props, {\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        varyings: varyingsArray\n      })\n    );\n  }\n\n  // assert on required parameters\n  /* eslint-disable complexity */\n  _validateProps(props) {\n    let {feedbackBuffers, feedbackMap} = props;\n\n    // backward compitability\n    const {destinationBuffers, sourceDestinationMap} = props;\n    if (destinationBuffers) {\n      log.deprecated('destinationBuffers', 'feedbackBuffers')();\n      feedbackBuffers = feedbackBuffers || destinationBuffers;\n    }\n    if (sourceDestinationMap) {\n      log.deprecated('sourceDestinationMap', 'feedbackMap')();\n      feedbackMap = feedbackMap || sourceDestinationMap;\n    }\n\n    // assert on required parameters\n    const {vs, elementCount, varyings} = props;\n    const {_sourceTextures, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    assert(\n      vs &&\n        // destinations are provided\n        (varyings || feedbackMap || _targetTexture) &&\n        // when only writting to textures auto-duduce from texture dimenstions\n        elementCount\n    );\n\n    for (const bufferName in feedbackBuffers || {}) {\n      assert(\n        feedbackBuffers[bufferName] instanceof Buffer ||\n          feedbackBuffers[bufferName].buffer instanceof Buffer\n      );\n    }\n    for (const textureName in _sourceTextures || {}) {\n      assert(_sourceTextures[textureName] instanceof Texture2D);\n    }\n\n    // If rendering to texture , varying is provided\n    assert(!_targetTexture || _targetTextureVarying);\n\n    // swap texture must be a valid source texture\n    assert(!_swapTexture || _sourceTextures[_swapTexture]);\n\n    return {feedbackBuffers, feedbackMap};\n  }\n  /* eslint-enable complexity */\n\n  // setup source and destination buffers\n  _setupBuffers({sourceBuffers = null, feedbackBuffers = null}) {\n    this.sourceBuffers[0] = Object.assign({}, sourceBuffers);\n    this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);\n    this._createFeedbackBuffers({feedbackBuffers});\n    this.sourceBuffers[1] = {};\n    this.feedbackBuffers[1] = {};\n  }\n\n  // setup source and destination textures\n  _setupTextures(props = {}) {\n    const {_sourceTextures, _targetTexture} = props;\n    // Setup source texture\n    this.sourceTextures[0] = Object.assign({}, _sourceTextures);\n    this.sourceTextures[1] = {};\n    this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;\n\n    if (this.targetTextureVarying) {\n      const texture = this._buildTargetTexture(_targetTexture, 0);\n      // Either a texture or refAttribute must be provided\n      assert(texture);\n      this.targetTextures[0] = texture;\n      this.targetTextures[1] = null;\n    }\n  }\n\n  // Builds target texture using source reference or provided texture object.\n  _buildTargetTexture(textureOrAttribute, index) {\n    if (textureOrAttribute instanceof Texture2D) {\n      return textureOrAttribute;\n    }\n    const refTexture = this.sourceTextures[0][textureOrAttribute];\n    if (!refTexture) {\n      return null;\n    }\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrAttribute;\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // track the new texture created above\n    // there can only be two target textures, index 0 and index 1\n    const resourceName = `target-texture-${index}`;\n    if (this.resources[resourceName]) {\n      this.resources[resourceName].delete();\n    }\n    this.resources[resourceName] = texture;\n\n    return texture;\n  }\n\n  // auto create any feedback buffers\n  _createFeedbackBuffers({feedbackBuffers}) {\n    if (!this.feedbackMap) {\n      // feedbackMap required to auto create buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    for (const sourceBufferName in this.feedbackMap) {\n      const feedbackBufferName = this.feedbackMap[sourceBufferName];\n      if (\n        feedbackBufferName !== this.targetTextureVarying &&\n        (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])\n      ) {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = this.sourceBuffers[current][sourceBufferName];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        const buffer = this._createNewBuffer(feedbackBufferName, {byteLength, usage, accessor});\n        this.feedbackBuffers[current][feedbackBufferName] = buffer;\n      }\n    }\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  // setup buffers for swapping.\n  // Second set of source and feedback objects are setup to point\n  // to corresponding feedback and source buffers.\n  _setupSwapBuffers() {\n    if (!this.feedbackMap) {\n      // feedbackMap required set up swap buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    // Copy all buffers/textures so un-mapped sources will remain same\n    Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);\n    Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);\n\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      // TODO: add textureMap and remove this if loop\n      if (dstName !== this.targetTextureVarying) {\n        this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];\n        this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName];\n\n        // make sure the new destination buffer is a Buffer object\n        assert(this.feedbackBuffers[next][dstName] instanceof Buffer);\n      }\n    }\n\n    // When triggered by `update()` TranformFeedback objects are already set up,\n    // if so update buffers\n    if (this.transformFeedbacks[next]) {\n      this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);\n    }\n\n    // TODO: add swap support for targetTexture and framebuffers\n  }\n\n  // setup textures for swapping.\n  _setupSwapTextures() {\n    if (!this._swapTexture || !this.targetTextureVarying) {\n      // Must be rendering to a texture and _swapTexture is provided\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    Object.assign(this.sourceTextures[next], this.sourceTextures[current]);\n\n    this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];\n\n    this._updateTargetTexture(this.sourceTextures[current][this._swapTexture], next);\n  }\n\n  // build Model and TransformFeedback objects\n  _buildModel(props = {}) {\n    const {vs, fs, modules, uniforms, inject, samplerTextureMap} = this._getShaders(props);\n    this.model = new Model(\n      this.gl,\n      Object.assign({}, props, {\n        vs,\n        fs,\n        vertexCount: props.elementCount,\n        modules,\n        uniforms,\n        inject\n      })\n    );\n    this.samplerTextureMap = samplerTextureMap;\n\n    // setup TF to capture varyings.\n    this._setupTransformFeedback();\n\n    // setup Framebuffer object for rendering to Texture.\n    this._setupFramebuffers();\n\n    // create buffer to access source texture pixesl.\n    this._setElementCount(props.elementCount);\n  }\n\n  // setup TransformFeedback objects to capture the results\n  _setupTransformFeedback() {\n    if (isObjectEmpty(this.feedbackBuffers[0])) {\n      return;\n    }\n    this.transformFeedbacks[0] = new TransformFeedback(this.gl, {\n      program: this.model.program,\n      buffers: this.feedbackBuffers[0]\n    });\n\n    // If buffers are swappable setup second transform feedback object.\n    if (this.feedbackMap) {\n      this.transformFeedbacks[1] = new TransformFeedback(this.gl, {\n        program: this.model.program,\n        buffers: this.feedbackBuffers[1]\n      });\n    }\n  }\n\n  // setup framebuffers with texture attachments, to which results are rendered\n  _setupFramebuffers() {\n    if (!this.renderingToTexture) {\n      return;\n    }\n\n    let {width, height} = this.targetTextures[0];\n    this.framebuffers[0] = new Framebuffer(this.gl, {\n      id: `${this.id || 'transform'}-framebuffer-0`,\n      width,\n      height,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: this.targetTextures[0]\n      }\n    });\n\n    if (this._swapTexture) {\n      ({width, height} = this.targetTextures[1]);\n\n      this.framebuffers[1] = new Framebuffer(this.gl, {\n        id: `${this.id || 'transform'}-framebuffer-1`,\n        width,\n        height,\n        attachments: {\n          [GL.COLOR_ATTACHMENT0]: this.targetTextures[1]\n        }\n      });\n    }\n  }\n\n  // create/update buffer to access source texture's individual pixels.\n  _updateElementIDBuffer(elementCount) {\n    if (!this.hasSourceTextures && !this.targetTextureVarying) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = this._createNewBuffer('elementIDBuffer', {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n  }\n\n  // build and return shader releated parameters\n  _getShaders(props = {}) {\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = this._processVertexShader(\n      props.vs\n    );\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transform].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject, samplerTextureMap};\n  }\n\n  // scan and update vertex shader for texture atrributes.\n  _processVertexShader(vs) {\n    return updateForTextures({\n      vs,\n      sourceTextureMap: this.sourceTextures[this.currentIndex],\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture: this.targetTextures[this.currentIndex]\n    });\n  }\n}\n"],"file":"transform.js"}