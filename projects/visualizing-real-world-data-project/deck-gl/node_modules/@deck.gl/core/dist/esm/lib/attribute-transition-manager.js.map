{"version":3,"sources":["../../../src/lib/attribute-transition-manager.js"],"names":["Buffer","Transform","getShaders","getBuffers","padBuffer","Attribute","BaseAttribute","Transition","log","assert","noop","DEFAULT_TRANSITION_SETTINGS","duration","easing","t","onStart","onEnd","onInterrupt","AttributeTransitionManager","gl","id","attributeTransitions","needsRedraw","transform","numInstances","isSupported","warn","delete","attributeName","_removeTransition","attributes","transitions","opts","changedTransitions","hasChanged","_updateAttribute","attribute","supportsTransition","_createModel","sourceBuffers","feedbackBuffers","update","elementCount","animatedAttributes","transition","buffer","attributeInTransition","currentTime","uniforms","updated","time","run","name","bufferLayout","_invalidateModel","_swapBuffer","settings","getTransitionSetting","_createTransition","_triggerTransition","Object","keys","length","assign","size","offset","normalized","toState","constant","value","getBuffer","divisor","externalBuffer","fromState","toLength","userData","noAlloc","fromLength","getElementCount","data","Float32Array","usage","setData","fromBufferLayout","toBufferLayout","elementOffset","getData","enter","transitionSettings","start","_getNextTransitionStates"],"mappings":";;AACA,SAAQA,MAAR,EAAgBC,SAAhB,QAAgC,eAAhC;AACA,SAAQC,UAAR,EAAoBC,UAApB,EAAgCC,SAAhC,QAAgD,8BAAhD;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,aAAP,MAA0B,kBAA1B;AACA,OAAOC,UAAP,MAAuB,2BAAvB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;;AAEA,IAAMC,IAAI,GAAG,SAAPA,IAAO,GAAM,CAAE,CAArB;;AACA,IAAMC,2BAA2B,GAAG;AAClCC,EAAAA,QAAQ,EAAE,CADwB;AAElCC,EAAAA,MAAM,EAAE,gBAAAC,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAFyB;AAGlCC,EAAAA,OAAO,EAAEL,IAHyB;AAIlCM,EAAAA,KAAK,EAAEN,IAJ2B;AAKlCO,EAAAA,WAAW,EAAEP;AALqB,CAApC;;IAQqBQ,0B;AACnB,sCAAYC,EAAZ,QAAsB;AAAA,QAALC,EAAK,QAALA,EAAK;;AAAA;;AACpB,SAAKA,EAAL,GAAUA,EAAV;AACA,SAAKD,EAAL,GAAUA,EAAV;AAEA,SAAKE,oBAAL,GAA4B,EAA5B;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,YAAL,GAAoB,CAApB;;AAEA,QAAIvB,SAAS,CAACwB,WAAV,CAAsBN,EAAtB,CAAJ,EAA+B;AAC7B,WAAKM,WAAL,GAAmB,IAAnB;AACD,KAFD,MAEO,IAAIN,EAAJ,EAAQ;AAEbX,MAAAA,GAAG,CAACkB,IAAJ,CAAS,yEAAT;AACD;AACF;;;;+BAEU;AACT,UAAI,KAAKH,SAAT,EAAoB;AAClB,aAAKA,SAAL,CAAeI,MAAf;AACD;;AACD,WAAK,IAAMC,aAAX,IAA4B,KAAKP,oBAAjC,EAAuD;AACrD,aAAKQ,iBAAL,CAAuBD,aAAvB;AACD;AACF;;;kCAMoD;AAAA,UAA7CE,UAA6C,SAA7CA,UAA6C;AAAA,oCAAjCC,WAAiC;AAAA,UAAjCA,WAAiC,kCAAnB,EAAmB;AAAA,UAAfP,YAAe,SAAfA,YAAe;AACnD,WAAKQ,IAAL,GAAYD,WAAZ;AAEA,WAAKP,YAAL,GAAoBA,YAAY,IAAI,CAApC;;AAEA,UAAI,CAAC,KAAKC,WAAV,EAAuB;AACrB;AACD;;AAPkD,UAS5CJ,oBAT4C,GASpB,IAToB,CAS5CA,oBAT4C;AAUnD,UAAMY,kBAAkB,GAAG,EAA3B;;AAEA,WAAK,IAAML,aAAX,IAA4BE,UAA5B,EAAwC;AACtC,YAAMI,UAAU,GAAG,KAAKC,gBAAL,CAAsBP,aAAtB,EAAqCE,UAAU,CAACF,aAAD,CAA/C,CAAnB;;AAEA,YAAIM,UAAJ,EAAgB;AACdD,UAAAA,kBAAkB,CAACL,aAAD,CAAlB,GAAoCP,oBAAoB,CAACO,aAAD,CAAxD;AACD;AACF;;AAED,WAAK,IAAMA,cAAX,IAA4BP,oBAA5B,EAAkD;AAChD,YAAMe,SAAS,GAAGN,UAAU,CAACF,cAAD,CAA5B;;AAEA,YAAI,CAACQ,SAAD,IAAc,CAACA,SAAS,CAACC,kBAAV,EAAnB,EAAmD;AAEjD,eAAKR,iBAAL,CAAuBD,cAAvB;AACD;AACF;;AAED,UAAI,CAAC,KAAKL,SAAV,EAAqB;AACnB,aAAKe,YAAL;AACD,OAFD,MAEO,IAAI,KAAKf,SAAT,EAAoB;AAAA,0BACgBpB,UAAU,CAAC8B,kBAAD,CAD1B;AAAA,YAClBM,aADkB,eAClBA,aADkB;AAAA,YACHC,eADG,eACHA,eADG;;AAEzB,aAAKjB,SAAL,CAAekB,MAAf,CAAsB;AACpBC,UAAAA,YAAY,EAAE,KAAKlB,YADC;AAEpBe,UAAAA,aAAa,EAAbA,aAFoB;AAGpBC,UAAAA,eAAe,EAAfA;AAHoB,SAAtB;AAKD;AACF;;;iCAGYZ,a,EAAe;AAC1B,aAAOA,aAAa,IAAI,KAAKP,oBAA7B;AACD;;;oCAGe;AACd,UAAMsB,kBAAkB,GAAG,EAA3B;;AAEA,WAAK,IAAMf,aAAX,IAA4B,KAAKP,oBAAjC,EAAuD;AACrD,YAAMuB,UAAU,GAAG,KAAKvB,oBAAL,CAA0BO,aAA1B,CAAnB;;AAEA,YAAIgB,UAAU,CAACC,MAAf,EAAuB;AACrBF,UAAAA,kBAAkB,CAACf,aAAD,CAAlB,GAAoCgB,UAAU,CAACE,qBAA/C;AACD;AACF;;AAED,aAAOH,kBAAP;AACD;;;mCAKcI,W,EAAa;AAC1B,UAAI,CAAC,KAAKxB,SAAN,IAAmB,KAAKC,YAAL,KAAsB,CAA7C,EAAgD;AAC9C,eAAO,KAAP;AACD;;AAED,UAAMwB,QAAQ,GAAG,EAAjB;AAEA,UAAI1B,WAAW,GAAG,KAAKA,WAAvB;AACA,WAAKA,WAAL,GAAmB,KAAnB;;AAEA,WAAK,IAAMM,aAAX,IAA4B,KAAKP,oBAAjC,EAAuD;AACrD,YAAMuB,UAAU,GAAG,KAAKvB,oBAAL,CAA0BO,aAA1B,CAAnB;AACA,YAAMqB,OAAO,GAAGL,UAAU,CAACH,MAAX,CAAkBM,WAAlB,CAAhB;;AACA,YAAIE,OAAJ,EAAa;AACXD,UAAAA,QAAQ,WAAIpB,aAAJ,UAAR,GAAmCgB,UAAU,CAACM,IAA9C;AACA5B,UAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AAED,UAAIA,WAAJ,EAAiB;AACf,aAAKC,SAAL,CAAe4B,GAAf,CAAmB;AAACH,UAAAA,QAAQ,EAARA;AAAD,SAAnB;AACD;;AAED,aAAO1B,WAAP;AACD;;;sCAIiBM,a,EAAeQ,S,EAAW;AAC1C,UAAIQ,UAAU,GAAG,KAAKvB,oBAAL,CAA0BO,aAA1B,CAAjB;;AACA,UAAI,CAACgB,UAAL,EAAiB;AACfA,QAAAA,UAAU,GAAG,IAAIrC,UAAJ,CAAe;AAC1B6C,UAAAA,IAAI,EAAExB,aADoB;AAE1BQ,UAAAA,SAAS,EAATA,SAF0B;AAG1BU,UAAAA,qBAAqB,EAAE,IAAIzC,SAAJ,CAAc,KAAKc,EAAnB,EAAuBiB,SAAvB,CAHG;AAI1BiB,UAAAA,YAAY,EAAEjB,SAAS,CAACiB;AAJE,SAAf,CAAb;AAMA,aAAKhC,oBAAL,CAA0BO,aAA1B,IAA2CgB,UAA3C;;AACA,aAAKU,gBAAL;;AACA,eAAOV,UAAP;AACD;;AACD,aAAO,IAAP;AACD;;;sCAEiBhB,a,EAAe;AAC/B,UAAMgB,UAAU,GAAG,KAAKvB,oBAAL,CAA0BO,aAA1B,CAAnB;;AACA,UAAIgB,UAAJ,EAAgB;AACd,YAAIA,UAAU,CAACC,MAAf,EAAuB;AACrBD,UAAAA,UAAU,CAACC,MAAX,CAAkBlB,MAAlB;AACD;;AACD,YAAIiB,UAAU,CAACW,WAAf,EAA4B;AAC1BX,UAAAA,UAAU,CAACW,WAAX,CAAuB5B,MAAvB;AACD;;AACD,eAAO,KAAKN,oBAAL,CAA0BO,aAA1B,CAAP;;AACA,aAAK0B,gBAAL;AACD;AACF;;;qCAIgB1B,a,EAAeQ,S,EAAW;AACzC,UAAMoB,QAAQ,GAAGpB,SAAS,CAACqB,oBAAV,CAA+B,KAAKzB,IAApC,CAAjB;;AAEA,UAAIwB,QAAJ,EAAc;AACZ,YAAItB,UAAJ;AACA,YAAIU,UAAU,GAAG,KAAKvB,oBAAL,CAA0BO,aAA1B,CAAjB;;AACA,YAAIgB,UAAJ,EAAgB;AACdV,UAAAA,UAAU,GAAGE,SAAS,CAACd,WAAV,EAAb;AACD,SAFD,MAEO;AAELsB,UAAAA,UAAU,GAAG,KAAKc,iBAAL,CAAuB9B,aAAvB,EAAsCQ,SAAtC,CAAb;AACAF,UAAAA,UAAU,GAAG,IAAb;AACD;;AAED,YAAIA,UAAJ,EAAgB;AACd,eAAKyB,kBAAL,CAAwBf,UAAxB,EAAoCY,QAApC;;AACA,iBAAO,IAAP;AACD;AACF;;AAED,aAAO,KAAP;AACD;;;uCAGkB;AACjB,UAAI,KAAKjC,SAAT,EAAoB;AAClB,aAAKA,SAAL,CAAeI,MAAf;AACA,aAAKJ,SAAL,GAAiB,IAAjB;AACD;AACF;;;mCAGc;AACb,UAAIqC,MAAM,CAACC,IAAP,CAAY,KAAKxC,oBAAjB,EAAuCyC,MAAvC,KAAkD,CAAtD,EAAyD;AAEvD;AACD;;AACD,WAAKvC,SAAL,GAAiB,IAAItB,SAAJ,CACf,KAAKkB,EADU,EAEfyC,MAAM,CAACG,MAAP,CACE;AACErB,QAAAA,YAAY,EAAE,KAAKlB;AADrB,OADF,EAIErB,UAAU,CAAC,KAAKkB,oBAAN,CAJZ,EAKEnB,UAAU,CAAC,KAAKmB,oBAAN,CALZ,CAFe,CAAjB;AAUD;;;6CAGwBuB,U,EAAYY,Q,EAAU;AAAA,UACtCpB,SADsC,GACzBQ,UADyB,CACtCR,SADsC;AAAA,UAEtC4B,IAFsC,GAEV5B,SAFU,CAEtC4B,IAFsC;AAAA,UAEhCC,MAFgC,GAEV7B,SAFU,CAEhC6B,MAFgC;AAAA,UAExBC,UAFwB,GAEV9B,SAFU,CAExB8B,UAFwB;AAI7C,UAAIC,OAAJ;;AACA,UAAI/B,SAAS,CAACgC,QAAd,EAAwB;AACtBD,QAAAA,OAAO,GAAG,IAAI7D,aAAJ,CAAkB,KAAKa,EAAvB,EAA2B;AAACiD,UAAAA,QAAQ,EAAE,IAAX;AAAiBC,UAAAA,KAAK,EAAEjC,SAAS,CAACiC,KAAlC;AAAyCL,UAAAA,IAAI,EAAJA,IAAzC;AAA+CC,UAAAA,MAAM,EAANA;AAA/C,SAA3B,CAAV;AACD,OAFD,MAEO;AACLE,QAAAA,OAAO,GAAG,IAAI7D,aAAJ,CAAkB,KAAKa,EAAvB,EAA2B;AACnCiD,UAAAA,QAAQ,EAAE,KADyB;AAEnCvB,UAAAA,MAAM,EAAET,SAAS,CAACkC,SAAV,EAF2B;AAGnCC,UAAAA,OAAO,EAAE,CAH0B;AAInCP,UAAAA,IAAI,EAAJA,IAJmC;AAKnCC,UAAAA,MAAM,EAANA,MALmC;AAMnCC,UAAAA,UAAU,EAAVA,UANmC;AASnCG,UAAAA,KAAK,EAAEjC,SAAS,CAACoC,cAAV,GAA2B,IAA3B,GAAkCpC,SAAS,CAACiC;AAThB,SAA3B,CAAV;AAWD;;AACD,UAAMI,SAAS,GAAG7B,UAAU,CAACC,MAAX,IAAqBsB,OAAvC;AACA,UAAMO,QAAQ,GAAGtC,SAAS,CAACuC,QAAV,CAAmBC,OAAnB,GAA6BxC,SAAS,CAACiC,KAAV,CAAgBP,MAA7C,GAAsD,KAAKtC,YAAL,GAAoBwC,IAA3F;AACA,UAAMa,UAAU,GAAIJ,SAAS,YAAYzE,MAArB,IAA+ByE,SAAS,CAACK,eAAV,EAAhC,IAAgEJ,QAAnF;AAKA,UAAI7B,MAAM,GAAGD,UAAU,CAACW,WAAxB;AACAX,MAAAA,UAAU,CAACW,WAAX,GAAyBX,UAAU,CAACC,MAApC;;AAEA,UAAI,CAACA,MAAL,EAAa;AACXA,QAAAA,MAAM,GAAG,IAAI7C,MAAJ,CAAW,KAAKmB,EAAhB,EAAoB;AAC3B4D,UAAAA,IAAI,EAAE,IAAIC,YAAJ,CAAiBN,QAAjB,CADqB;AAE3BO,UAAAA,KAAK;AAFsB,SAApB,CAAT;AAID,OALD,MAKO,IAAIpC,MAAM,CAACiC,eAAP,KAA2BJ,QAA/B,EAAyC;AAE9C7B,QAAAA,MAAM,CAACqC,OAAP,CAAe;AACbH,UAAAA,IAAI,EAAE,IAAIC,YAAJ,CAAiBN,QAAjB;AADO,SAAf;AAGD;;AAED9B,MAAAA,UAAU,CAACE,qBAAX,CAAiCL,MAAjC,CAAwC;AAACI,QAAAA,MAAM,EAANA;AAAD,OAAxC;AAEAzC,MAAAA,SAAS,CAAC;AACRqE,QAAAA,SAAS,EAATA,SADQ;AAERN,QAAAA,OAAO,EAAPA,OAFQ;AAGRU,QAAAA,UAAU,EAAVA,UAHQ;AAIRH,QAAAA,QAAQ,EAARA,QAJQ;AAKRS,QAAAA,gBAAgB,EAAEvC,UAAU,CAACS,YALrB;AAMR+B,QAAAA,cAAc,EAAEhD,SAAS,CAACiB,YANlB;AAORY,QAAAA,MAAM,EAAE7B,SAAS,CAACiD,aAPV;AAQRC,QAAAA,OAAO,EAAE9B,QAAQ,CAAC+B;AARV,OAAD,CAAT;AAWA3C,MAAAA,UAAU,CAACS,YAAX,GAA0BjB,SAAS,CAACiB,YAApC;AAEA,aAAO;AAACoB,QAAAA,SAAS,EAATA,SAAD;AAAYN,QAAAA,OAAO,EAAPA,OAAZ;AAAqBtB,QAAAA,MAAM,EAANA;AAArB,OAAP;AACD;;;uCAIkBD,U,EAAYY,Q,EAAU;AAEvC/C,MAAAA,MAAM,CAAC+C,QAAQ,IAAIA,QAAQ,CAAC5C,QAAT,GAAoB,CAAjC,CAAN;AAEA,WAAKU,WAAL,GAAmB,IAAnB;AAEA,UAAMkE,kBAAkB,GAAG5B,MAAM,CAACG,MAAP,CAAc,EAAd,EAAkBpD,2BAAlB,EAA+C6C,QAA/C,CAA3B;AAGAZ,MAAAA,UAAU,CAAC6C,KAAX,CACE7B,MAAM,CAACG,MAAP,CAAc,EAAd,EAAkB,KAAK2B,wBAAL,CAA8B9C,UAA9B,EAA0CY,QAA1C,CAAlB,EAAuEgC,kBAAvE,CADF;AAGD;;;;;;SAvRkBtE,0B","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport {getShaders, getBuffers, padBuffer} from './attribute-transition-utils';\nimport Attribute from './attribute';\nimport BaseAttribute from './base-attribute';\nimport Transition from '../transitions/transition';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst noop = () => {};\nconst DEFAULT_TRANSITION_SETTINGS = {\n  duration: 0,\n  easing: t => t,\n  onStart: noop,\n  onEnd: noop,\n  onInterrupt: noop\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributeTransitions = {};\n    this.needsRedraw = false;\n    this.transform = null;\n    this.numInstances = 0;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      // This class may be instantiated without a WebGL context (e.g. web worker)\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    if (this.transform) {\n      this.transform.delete();\n    }\n    for (const attributeName in this.attributeTransitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    this.opts = transitions;\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    const {attributeTransitions} = this;\n    const changedTransitions = {};\n\n    for (const attributeName in attributes) {\n      const hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);\n\n      if (hasChanged) {\n        changedTransitions[attributeName] = attributeTransitions[attributeName];\n      }\n    }\n\n    for (const attributeName in attributeTransitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.supportsTransition()) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n\n    if (!this.transform) {\n      this._createModel();\n    } else if (this.transform) {\n      const {sourceBuffers, feedbackBuffers} = getBuffers(changedTransitions);\n      this.transform.update({\n        elementCount: this.numInstances,\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    return attributeName in this.attributeTransitions;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      if (transition.buffer) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  setCurrentTime(currentTime) {\n    if (!this.transform || this.numInstances === 0) {\n      return false;\n    }\n\n    const uniforms = {};\n\n    let needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n      const updated = transition.update(currentTime);\n      if (updated) {\n        uniforms[`${attributeName}Time`] = transition.time;\n        needsRedraw = true;\n      }\n    }\n\n    if (needsRedraw) {\n      this.transform.run({uniforms});\n    }\n\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _createTransition(attributeName, attribute) {\n    let transition = this.attributeTransitions[attributeName];\n    if (!transition) {\n      transition = new Transition({\n        name: attributeName,\n        attribute,\n        attributeInTransition: new Attribute(this.gl, attribute),\n        bufferLayout: attribute.bufferLayout\n      });\n      this.attributeTransitions[attributeName] = transition;\n      this._invalidateModel();\n      return transition;\n    }\n    return null;\n  }\n\n  _removeTransition(attributeName) {\n    const transition = this.attributeTransitions[attributeName];\n    if (transition) {\n      if (transition.buffer) {\n        transition.buffer.delete();\n      }\n      if (transition._swapBuffer) {\n        transition._swapBuffer.delete();\n      }\n      delete this.attributeTransitions[attributeName];\n      this._invalidateModel();\n    }\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute) {\n    const settings = attribute.getTransitionSetting(this.opts);\n\n    if (settings) {\n      let hasChanged;\n      let transition = this.attributeTransitions[attributeName];\n      if (transition) {\n        hasChanged = attribute.needsRedraw();\n      } else {\n        // New animated attributes have been added\n        transition = this._createTransition(attributeName, attribute);\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this._triggerTransition(transition, settings);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Invalidates the current model\n  _invalidateModel() {\n    if (this.transform) {\n      this.transform.delete();\n      this.transform = null;\n    }\n  }\n\n  // Create a model for the transform feedback\n  _createModel() {\n    if (Object.keys(this.attributeTransitions).length === 0) {\n      // no transitions\n      return;\n    }\n    this.transform = new Transform(\n      this.gl,\n      Object.assign(\n        {\n          elementCount: this.numInstances\n        },\n        getBuffers(this.attributeTransitions),\n        getShaders(this.attributeTransitions)\n      )\n    );\n  }\n\n  // get current values of an attribute, clipped/padded to the size of the new buffer\n  _getNextTransitionStates(transition, settings) {\n    const {attribute} = transition;\n    const {size, offset, normalized} = attribute;\n\n    let toState;\n    if (attribute.constant) {\n      toState = new BaseAttribute(this.gl, {constant: true, value: attribute.value, size, offset});\n    } else {\n      toState = new BaseAttribute(this.gl, {\n        constant: false,\n        buffer: attribute.getBuffer(),\n        divisor: 0,\n        size,\n        offset,\n        normalized,\n        // attribute's `value` does not match the content of external buffer,\n        // will need to call buffer.getData if needed\n        value: attribute.externalBuffer ? null : attribute.value\n      });\n    }\n    const fromState = transition.buffer || toState;\n    const toLength = attribute.userData.noAlloc ? attribute.value.length : this.numInstances * size;\n    const fromLength = (fromState instanceof Buffer && fromState.getElementCount()) || toLength;\n\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the destination buffer.\n    let buffer = transition._swapBuffer;\n    transition._swapBuffer = transition.buffer;\n\n    if (!buffer) {\n      buffer = new Buffer(this.gl, {\n        data: new Float32Array(toLength),\n        usage: GL.DYNAMIC_COPY\n      });\n    } else if (buffer.getElementCount() < toLength) {\n      // Pad buffers to be the same length\n      buffer.setData({\n        data: new Float32Array(toLength)\n      });\n    }\n\n    transition.attributeInTransition.update({buffer});\n\n    padBuffer({\n      fromState,\n      toState,\n      fromLength,\n      toLength,\n      fromBufferLayout: transition.bufferLayout,\n      toBufferLayout: attribute.bufferLayout,\n      offset: attribute.elementOffset,\n      getData: settings.enter\n    });\n\n    transition.bufferLayout = attribute.bufferLayout;\n\n    return {fromState, toState, buffer};\n  }\n\n  // Start a new transition using the current settings\n  // Updates transition state and from/to buffer\n  _triggerTransition(transition, settings) {\n    // Check if settings is valid\n    assert(settings && settings.duration > 0);\n\n    this.needsRedraw = true;\n\n    const transitionSettings = Object.assign({}, DEFAULT_TRANSITION_SETTINGS, settings);\n\n    // Attribute descriptor to transition from\n    transition.start(\n      Object.assign({}, this._getNextTransitionStates(transition, settings), transitionSettings)\n    );\n  }\n}\n"],"file":"attribute-transition-manager.js"}