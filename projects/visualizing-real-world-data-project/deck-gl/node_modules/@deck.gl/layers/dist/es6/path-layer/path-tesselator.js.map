{"version":3,"sources":["../../../src/path-layer/path-tesselator.js"],"names":["experimental","fp64LowPart","Tesselator","START_CAP","END_CAP","INVALID","PathTesselator","constructor","data","getGeometry","positionFormat","fp64","attributes","startPositions","size","padding","endPositions","segmentTypes","type","Uint8ClampedArray","startPositions64XyLow","fp64Only","endPositions64XyLow","get","attributeName","getGeometrySize","path","numPoints","getPathLength","isClosed","updateGeometryAttributes","context","geometrySize","isPathClosed","startPoint","endPoint","i","vertexStart","ptIndex","getPointOnPath","Number","isFinite","length","positionSize","index","firstPoint","lastPoint"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {experimental, fp64LowPart} from '@deck.gl/core';\nconst {Tesselator} = experimental;\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator {\n  constructor({data, getGeometry, positionFormat, fp64}) {\n    super({\n      data,\n      getGeometry,\n      fp64,\n      positionFormat,\n      attributes: {\n        startPositions: {size: 3, padding: 3},\n        endPositions: {size: 3, padding: 3},\n        segmentTypes: {size: 1, type: Uint8ClampedArray},\n        startPositions64XyLow: {size: 2, padding: 2, fp64Only: true},\n        endPositions64XyLow: {size: 2, padding: 2, fp64Only: true}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  getGeometrySize(path) {\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 1;\n    }\n    return numPoints - 1;\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateGeometryAttributes(path, context) {\n    const {\n      attributes: {\n        startPositions,\n        endPositions,\n        startPositions64XyLow,\n        endPositions64XyLow,\n        segmentTypes\n      },\n      fp64\n    } = this;\n\n    const {geometrySize} = context;\n    if (geometrySize === 0) {\n      return;\n    }\n    const isPathClosed = this.isClosed(path);\n\n    let startPoint;\n    let endPoint;\n\n    // startPositions   --  A0  B0 B1 B2 B3 B0 B1\n    // endPositions         A1  B1 B2 B3 B0 B1 B2  --\n    // segmentTypes         3   4  0  0  0  0  4\n    for (let i = context.vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      startPoint = endPoint || this.getPointOnPath(path, 0);\n      endPoint = this.getPointOnPath(path, ptIndex + 1);\n\n      segmentTypes[i] = 0;\n      if (ptIndex === 0) {\n        if (isPathClosed) {\n          segmentTypes[i] += INVALID;\n        } else {\n          segmentTypes[i] += START_CAP;\n        }\n      }\n      if (ptIndex === geometrySize - 1) {\n        if (isPathClosed) {\n          segmentTypes[i] += INVALID;\n        } else {\n          segmentTypes[i] += END_CAP;\n        }\n      }\n\n      startPositions[i * 3 + 3] = startPoint[0];\n      startPositions[i * 3 + 4] = startPoint[1];\n      startPositions[i * 3 + 5] = startPoint[2] || 0;\n\n      endPositions[i * 3] = endPoint[0];\n      endPositions[i * 3 + 1] = endPoint[1];\n      endPositions[i * 3 + 2] = endPoint[2] || 0;\n\n      if (fp64) {\n        startPositions64XyLow[i * 2 + 2] = fp64LowPart(startPoint[0]);\n        startPositions64XyLow[i * 2 + 3] = fp64LowPart(startPoint[1]);\n        endPositions64XyLow[i * 2] = fp64LowPart(endPoint[0]);\n        endPositions64XyLow[i * 2 + 1] = fp64LowPart(endPoint[1]);\n      }\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  /* Utilities */\n  getPathLength(path) {\n    if (Number.isFinite(path[0])) {\n      // flat format\n      return path.length / this.positionSize;\n    }\n    return path.length;\n  }\n\n  getPointOnPath(path, index) {\n    if (Number.isFinite(path[0])) {\n      // flat format\n      const {positionSize} = this;\n      if (index * positionSize >= path.length) {\n        // loop\n        index += 1 - path.length / positionSize;\n      }\n      // TODO - avoid creating new arrays when using binary\n      return [\n        path[index * positionSize],\n        path[index * positionSize + 1],\n        positionSize === 3 ? path[index * positionSize + 2] : 0\n      ];\n    }\n    if (index >= path.length) {\n      // loop\n      index += 1 - path.length;\n    }\n    return path[index];\n  }\n\n  isClosed(path) {\n    const numPoints = this.getPathLength(path);\n    const firstPoint = this.getPointOnPath(path, 0);\n    const lastPoint = this.getPointOnPath(path, numPoints - 1);\n    return (\n      firstPoint[0] === lastPoint[0] &&\n      firstPoint[1] === lastPoint[1] &&\n      firstPoint[2] === lastPoint[2]\n    );\n  }\n}\n"],"file":"path-tesselator.js"}