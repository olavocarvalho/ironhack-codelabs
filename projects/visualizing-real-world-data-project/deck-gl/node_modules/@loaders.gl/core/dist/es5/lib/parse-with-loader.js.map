{"version":3,"sources":["../../../src/lib/parse-with-loader.js"],"names":["parseWithLoader","data","loader","options","url","parseTextSync","dataType","parse","parseSync","worker","name","parseWithLoaderSync","parseWithLoaderInBatches","parseInBatches","inputIterator","outputIterator","parseWithLoaderInBatchesSync","parseInBatchesSync"],"mappings":";;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;SAUsBA,e;;;;;qFAAf,iBAA+BC,IAA/B,EAAqCC,MAArC,EAA6CC,OAA7C,EAAsDC,GAAtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQ,6CAA+BH,IAA/B,EAAqCC,MAArC,CADR;;AAAA;AACLD,YAAAA,IADK;;AAAA,kBAIDC,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QAJvC;AAAA;AAAA;AAAA;;AAKHE,YAAAA,OAAO,CAACG,QAAR,GAAmB,MAAnB;AALG,6CAMIJ,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CANJ;;AAAA;AAAA,iBAUDA,MAAM,CAACK,KAVN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWUL,MAAM,CAACK,KAAP,CAAaN,IAAb,EAAmBE,OAAnB,EAA4BC,GAA5B,EAAiCF,MAAjC,CAXV;;AAAA;AAAA;;AAAA;AAAA,iBAeDA,MAAM,CAACM,SAfN;AAAA;AAAA;AAAA;;AAAA,6CAgBIN,MAAM,CAACM,SAAP,CAAiBP,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAhBJ;;AAAA;AAAA,iBAmBDA,MAAM,CAACO,MAnBN;AAAA;AAAA;AAAA;;AAAA,6CAoBI,iCAAgBP,MAAM,CAACO,MAAvB,EAA+BP,MAAM,CAACQ,IAAtC,EAA4CT,IAA5C,EAAkDE,OAAlD,CApBJ;;AAAA;AAAA,6CAyBE,wBAAO,KAAP,CAzBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA6BA,SAASQ,mBAAT,CAA6BV,IAA7B,EAAmCC,MAAnC,EAA2CC,OAA3C,EAAoDC,GAApD,EAAyD;AAC9DH,EAAAA,IAAI,GAAG,iDAAmCA,IAAnC,EAAyCC,MAAzC,CAAP;;AAEA,MAAIA,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QAA5C,EAAsD;AACpD,WAAOC,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CAAP;AACD;;AAED,MAAIA,MAAM,CAACM,SAAX,EAAsB;AACpB,WAAON,MAAM,CAACM,SAAP,CAAiBP,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAAP;AACD;;AAID,SAAO,wBAAO,KAAP,CAAP;AACD;;AAEM,SAASU,wBAAT,CAAkCX,IAAlC,EAAwCC,MAAxC,EAAgDC,OAAhD,EAAyDC,GAAzD,EAA8D;AAEnE,MAAIF,MAAM,CAACW,cAAX,EAA2B;AACzB,QAAMC,aAAa,GAAG,uCAAyBb,IAAzB,CAAtB;AACA,QAAMc,cAAc,GAAGb,MAAM,CAACW,cAAP,CAAsBC,aAAtB,EAAqCX,OAArC,EAA8CC,GAA9C,EAAmDF,MAAnD,CAAvB;AACA,WAAOa,cAAP;AACD;;AAGD,SAAO,IAAP;AACD;;AAEM,SAASC,4BAAT,CAAsCf,IAAtC,EAA4CC,MAA5C,EAAoDC,OAApD,EAA6DC,GAA7D,EAAkE;AAEvE,MAAIF,MAAM,CAACe,kBAAX,EAA+B;AAC7B,QAAMH,aAAa,GAAG,kCAAoBb,IAApB,CAAtB;AACA,QAAMc,cAAc,GAAGb,MAAM,CAACe,kBAAP,CAA0BH,aAA1B,EAAyCX,OAAzC,EAAkDC,GAAlD,EAAuDF,MAAvD,EAA+DE,GAA/D,CAAvB;AACA,WAAOW,cAAP;AACD;;AAED,SAAO,wBAAO,KAAP,CAAP;AACD","sourcesContent":["import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options, url) {\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return parseWithWorker(loader.worker, loader.name, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport function parseWithLoaderInBatches(data, loader, options, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport function parseWithLoaderInBatchesSync(data, loader, options, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n"],"file":"parse-with-loader.js"}