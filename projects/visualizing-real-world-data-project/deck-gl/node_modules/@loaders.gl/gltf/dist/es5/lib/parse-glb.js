"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGLB = isGLB;
exports["default"] = parseGLBSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

var MAGIC_glTF = 0x676c5446;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
var GLB_CHUNK_TYPE_BIN = 0x004e4942;
var LE = true;
var BE = false;

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
}

function isGLB(arrayBuffer) {
  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var dataView = new DataView(arrayBuffer);
  var _options$magic = options.magic,
      magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;
  var magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}

function parseGLBSync(glb, arrayBuffer) {
  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dataView = new DataView(arrayBuffer);
  glb.byteOffset = byteOffset;
  glb.magic = dataView.getUint32(byteOffset + 0, BE);
  glb.version = dataView.getUint32(byteOffset + 4, LE);
  glb.byteLength = dataView.getUint32(byteOffset + 8, LE);
  glb.type = getMagicString(dataView);
  var _options$magic2 = options.magic,
      magic = _options$magic2 === void 0 ? MAGIC_glTF : _options$magic2;
  var isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;

  if (!isMagicValid) {
    console.warn("Invalid GLB magic string ".concat(glb.type));
  }

  (0, _loaderUtils.assert)(glb.version === 2, "Invalid GLB version ".concat(glb.version, ". Only .glb v2 supported"));
  (0, _loaderUtils.assert)(glb.byteLength > 20);
  var jsonChunkLength = dataView.getUint32(byteOffset + 12, LE);
  var jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE);
  var isJSONChunk = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0;
  (0, _loaderUtils.assert)(isJSONChunk, "JSON chunk format ".concat(jsonChunkFormat));
  var jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;
  var jsonChunk = new Uint8Array(arrayBuffer, byteOffset + jsonChunkByteOffset, jsonChunkLength);
  var textDecoder = new TextDecoder('utf8');
  var jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  var binChunkStart = jsonChunkByteOffset + (0, _loaderUtils.padTo4Bytes)(jsonChunkLength);
  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;

  if (glb.hasBinChunk) {
    var binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);
    var binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);
    var isBinChunk = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1;
    (0, _loaderUtils.assert)(isBinChunk, "BIN chunk format ".concat(binChunkFormat));
    var binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;
    glb.binChunkByteOffset = binChunkByteOffset;
    glb.binChunkLength = binChunkLength;
  }

  return byteOffset + glb.byteLength;
}
//# sourceMappingURL=parse-glb.js.map