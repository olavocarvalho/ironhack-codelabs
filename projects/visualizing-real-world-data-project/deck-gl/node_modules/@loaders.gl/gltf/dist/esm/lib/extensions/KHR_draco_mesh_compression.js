import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import GLTFScenegraph from '../gltf-scenegraph';
import { KHR_DRACO_MESH_COMPRESSION } from '../gltf-constants';
import { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';

var KHR_draco_mesh_compression = function () {
  function KHR_draco_mesh_compression() {
    _classCallCheck(this, KHR_draco_mesh_compression);
  }

  _createClass(KHR_draco_mesh_compression, null, [{
    key: "decode",
    value: function decode(gltfData, options) {
      var gltfScenegraph = new GLTFScenegraph(gltfData);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (gltfScenegraph.json.meshes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var mesh = _step.value;
          KHR_draco_mesh_compression.decompressMesh(mesh, options);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      gltfScenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }, {
    key: "encode",
    value: function encode(gltfData, options) {
      var gltfScenegraph = new GLTFScenegraph(gltfData);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (gltfScenegraph.json.meshes || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var mesh = _step2.value;
          KHR_draco_mesh_compression.compressMesh(mesh, options);
          gltfScenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "compressMesh",
    value: function compressMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!options.DracoWriter || !options.DracoLoader) {
        throw new Error('DracoWriter/DracoLoader not available');
      }

      var compressedData = options.DracoWriter.encodeSync({
        attributes: attributes
      });
      var decodedData = options.DracoLoader.parseSync({
        attributes: attributes
      });

      var fauxAccessors = options._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = options.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          extensions: _defineProperty({}, KHR_DRACO_MESH_COMPRESSION, {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          })
        }]
      };
      return glTFMesh;
    }
  }, {
    key: "decompressMesh",
    value: function decompressMesh(mesh) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = mesh.primitives[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var primitive = _step3.value;

          KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);

          if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
            throw new Error('Empty glTF primitive: decompression failure?');
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "_decompressMeshPrimitive",
    value: function _decompressMeshPrimitive(primitive, options) {
      var compressedPrimitive = primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

      if (!compressedPrimitive) {
        return;
      }

      if (!options.DracoLoader || !options.decompress) {
        return;
      }

      delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

      var buffer = this._getBufferViewArray(compressedPrimitive.bufferView);

      var decodedData = options.DracoLoader.parseSync(buffer);
      primitive.attributes = getGLTFAccessors(decodedData.attributes);

      if (decodedData.indices) {
        primitive.indices = getGLTFAccessor(decodedData.indices);
      }
    }
  }, {
    key: "name",
    get: function get() {
      return KHR_DRACO_MESH_COMPRESSION;
    }
  }]);

  return KHR_draco_mesh_compression;
}();

export { KHR_draco_mesh_compression as default };
//# sourceMappingURL=KHR_draco_mesh_compression.js.map