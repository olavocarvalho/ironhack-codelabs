{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["GLTFScenegraph","KHR_DRACO_MESH_COMPRESSION","getGLTFAccessors","getGLTFAccessor","KHR_draco_mesh_compression","gltfData","options","gltfScenegraph","json","meshes","mesh","decompressMesh","removeExtension","compressMesh","addRequiredExtension","attributes","indices","mode","DracoWriter","DracoLoader","Error","compressedData","encodeSync","decodedData","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","bufferView","primitive","_decompressMeshPrimitive","Object","keys","length","compressedPrimitive","decompress","buffer","_getBufferViewArray"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nexport default class KHR_draco_mesh_compression {\n  static get name() {\n    return KHR_DRACO_MESH_COMPRESSION;\n  }\n\n  static decode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.decompressMesh(mesh, options);\n    }\n\n    // We have now decompressed all primitives, we can remove the top-level extensions\n    gltfScenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n\n  static encode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n\n    for (const mesh of gltfScenegraph.json.meshes || []) {\n      // eslint-disable-next-line camelcase\n      KHR_draco_mesh_compression.compressMesh(mesh, options);\n      // NOTE: We only add if something was actually compressed\n      gltfScenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  }\n\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  // Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n  static compressMesh(attributes, indices, mode = 4, options = {}) {\n    if (!options.DracoWriter || !options.DracoLoader) {\n      throw new Error('DracoWriter/DracoLoader not available');\n    }\n\n    const compressedData = options.DracoWriter.encodeSync({attributes});\n\n    // Draco compression may change the order and number of vertices in a mesh.\n    // To satisfy the requirement that accessors properties be correct for both\n    // compressed and uncompressed data, generators should create uncompressed\n    // attributes and indices using data that has been decompressed from the Draco buffer,\n    // rather than the original source data.\n    const decodedData = options.DracoLoader.parseSync({attributes});\n    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n    const bufferViewIndex = options.addBufferView(compressedData);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: fauxAccessors, // TODO - verify with spec\n          mode, // GL.POINTS\n          extensions: {\n            [KHR_DRACO_MESH_COMPRESSION]: {\n              bufferView: bufferViewIndex,\n              attributes: fauxAccessors // TODO - verify with spec\n            }\n          }\n        }\n      ]\n    };\n\n    return glTFMesh;\n  }\n\n  static decompressMesh(mesh, options = {}) {\n    // We have a \"soft dependency\" on Draco to avoid bundling it when not needed\n    // DracoEncoder needs to be imported and supplied by app\n    // Decompress all the primitives in a mesh\n    for (const primitive of mesh.primitives) {\n      KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);\n      if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {\n        throw new Error('Empty glTF primitive: decompression failure?');\n      }\n    }\n  }\n\n  // Unpacks one mesh primitive and removes the extension from the primitive\n  // TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n  // TODO - Decompression could be threaded: Use DracoWorkerLoader?\n  //\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  static _decompressMeshPrimitive(primitive, options) {\n    const compressedPrimitive =\n      primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n    if (!compressedPrimitive) {\n      return;\n    }\n\n    if (!options.DracoLoader || !options.decompress) {\n      return;\n    }\n\n    // Extension will be processed, delete it\n    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n    const buffer = this._getBufferViewArray(compressedPrimitive.bufferView);\n    const decodedData = options.DracoLoader.parseSync(buffer);\n    primitive.attributes = getGLTFAccessors(decodedData.attributes);\n    if (decodedData.indices) {\n      primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n  }\n}\n"],"file":"KHR_draco_mesh_compression.js"}