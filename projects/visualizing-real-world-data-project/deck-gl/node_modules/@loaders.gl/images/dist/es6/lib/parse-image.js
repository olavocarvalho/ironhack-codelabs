import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { global } from '../utils/globals';
import { getImageMetadata } from './get-image-metadata';
export var canParseImage = global._parseImageNode || typeof ImageBitmap !== 'undefined';
export function parseImage(arrayBuffer, options) {
  if (global._parseImageNode) {
    var {
      mimeType
    } = getImageMetadata(arrayBuffer);
    return global._parseImageNode(arrayBuffer, mimeType, options);
  }

  return parseToImageBitmap(arrayBuffer, options);
}
export function loadImage(_x) {
  return _loadImage.apply(this, arguments);
}

function _loadImage() {
  _loadImage = _asyncToGenerator(function* (url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof Image === 'undefined') {
      var response = yield fetch(url, options);
      var arrayBuffer = yield response.arrayBuffer();
      return parseImage(arrayBuffer, options);
    }

    return yield loadToHTMLImage(url, options);
  });
  return _loadImage.apply(this, arguments);
}

export function parseToImageBitmap(arrayBuffer, options) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  var blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}
export function loadToHTMLImage(_x2, _x3) {
  return _loadToHTMLImage.apply(this, arguments);
}

function _loadToHTMLImage() {
  _loadToHTMLImage = _asyncToGenerator(function* (url, options) {
    var src;

    if (/\.svg((\?|#).*)?$/.test(url)) {
      var response = yield fetch(url, options);
      var xml = yield response.text();
      src = "data:image/svg+xml;base64,".concat(btoa(xml));
    } else {
      src = yield url;
    }

    return yield new Promise((resolve, reject) => {
      try {
        var image = new Image();

        image.onload = () => resolve(image);

        image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));

        image.crossOrigin = options && options.crossOrigin || 'anonymous';
        image.src = src;
      } catch (error) {
        reject(error);
      }
    });
  });
  return _loadToHTMLImage.apply(this, arguments);
}
//# sourceMappingURL=parse-image.js.map