import { createMat4 } from './math-utils';
import { worldToPixels, pixelsToWorld } from './web-mercator-utils';
import * as mat4 from 'gl-matrix/mat4';
var IDENTITY = createMat4();
export default class Viewport {
  constructor() {
    var {
      width,
      height,
      viewMatrix = IDENTITY,
      projectionMatrix = IDENTITY
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;
    this.pixelsPerMeter = 1;
    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;
    var vpm = createMat4();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    var m = createMat4();
    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, this.viewProjectionMatrix);
    var mInverse = mat4.invert(createMat4(), m);

    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }

  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }

    return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
  }

  project(xyz) {
    var {
      topLeft = true
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var worldPosition = this.projectPosition(xyz);
    var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
    var [x, y] = coord;
    var y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }

  unproject(xyz) {
    var {
      topLeft = true,
      targetZ
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var [x, y, z] = xyz;
    var y2 = topLeft ? y : this.height - y;
    var targetZWorld = targetZ && targetZ * this.pixelsPerMeter;
    var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    var [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    var [X, Y] = this.projectFlat(xyz);
    var Z = (xyz[2] || 0) * this.pixelsPerMeter;
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    var [X, Y] = this.unprojectFlat(xyz);
    var Z = (xyz[2] || 0) / this.pixelsPerMeter;
    return [X, Y, Z];
  }

  projectFlat(xyz) {
    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
    return xyz;
  }

  unprojectFlat(xyz) {
    var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
    return xyz;
  }

}
//# sourceMappingURL=viewport.js.map